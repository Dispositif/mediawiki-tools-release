#!/usr/bin/env php
<?php

if ( php_sapi_name() !== 'cli' ) {
	echo "This script only works in CLI mode\n";
	exit( 1 );
}

if ( count( $argv ) < 3 ) {
	echo "Usage: make-wmf-branch <new-version> <old-version> <path to clone>\n";
	echo "Example: make-wmf-branch 1.20wmf2 1.20wmf1\n";
	echo " <path to clone>, if given, is a local clone on disk to use\n";
	exit( 1 );
}

$newVersion = $argv[1];
$oldVersion = $argv[2];
$clonePath = isset( $argv[3] ) ? $argv[3] : null;

$obj = new MakeWmfBranch( $newVersion, $oldVersion );
$obj->execute( $clonePath );

class MakeWmfBranch {
	var $dryRun;
	var $newVersion, $oldVersion, $buildDir;
	var $normalExtensions, $specialExtensions, $branchedExtensions, $patches;
	var $baseRepoPath, $anonRepoPath;
	var $noisy;

	function __construct( $newVersion, $oldVersion ) {
		$this->newVersion = $newVersion;
		$this->oldVersion = $oldVersion;
		$codeDir = dirname( __FILE__ );
		$buildDir = sys_get_temp_dir() . '/make-wmf-branch';

		require( "{$codeDir}/default.conf" );
		if ( file_exists( "{$codeDir}/local.conf" ) ) {
			require( "{$codeDir}/local.conf" );
		}

		$this->dryRun = $dryRun;
		$this->buildDir = $buildDir;
		$this->normalExtensions = $normalExtensions;
		$this->specialExtensions = $specialExtensions;
		$this->branchedExtensions = $branchedExtensions;
		$this->noisy = $noisy;
		$this->patches = $patches;
		$this->baseRepoPath = $baseRepoPath;
		$this->anonRepoPath = $anonRepoPath;
		$this->branchPrefix = $branchPrefix;
	}

	function runCmd( /*...*/ ) {
		$args = func_get_args();
		if( $this->noisy && in_array( "-q", $args ) ) {
			$args = array_diff( $args, array( "-q" ) );
		}
		$encArgs = array_map( 'escapeshellarg', $args );
		$cmd = implode( ' ', $encArgs );
		echo "$cmd\n";
		passthru( $cmd, $ret );
		if ( $ret ) {
			$this->croak( $args[0] . " exit with status $ret\n" );
		}
	}

	function runWriteCmd( /*...*/ ) {
		$args = func_get_args();
		if ( $this->dryRun ) {
			$encArgs = array_map( 'escapeshellarg', $args );
			$cmd = implode( ' ', $encArgs );
			echo "[dry-run] $cmd\n";
		} else {
			call_user_func_array( array( $this, 'runCmd' ), $args );
		}
	}

	function chdir( $dir ) {
		if ( !chdir( $dir ) ) {
			$this->croak( "Unable to change working directory\n" );
		}
		echo "cd $dir\n";
	}

	function croak( $msg ) {
		fwrite( STDERR, "$msg\n" );
		exit( 1 );
	}

	function execute( $clonePath ) {
		$this->setupBuildDirectory();
		$this->branchExtensions();
		$this->branchWmf( $clonePath );
	}

	function setupBuildDirectory() {
		# Create a temporary build directory
		if ( file_exists( $this->buildDir ) ) {
			$this->runCmd( 'rm', '-rf', '--', $this->buildDir );
		}
		if ( !mkdir( $this->buildDir ) ) {
			$this->croak( "Unable to create build directory {$this->buildDir}" );
		}
		$this->chdir( $this->buildDir );
	}
	
	function branchExtensions() {
		foreach( $this->branchedExtensions as $ext ) {
			$this->runCmd( 'git', 'clone', '-q', "{$this->baseRepoPath}/extensions/{$ext}.git", $ext );
			$this->chdir( "$ext" );
			$newVersion = $this->branchPrefix . $this->newVersion;
			$this->runCmd( 'git', 'branch', $newVersion );
			$this->runWriteCmd( 'git', 'push', 'origin', $newVersion );
			$this->chdir( $this->buildDir );
		}
	}

	function branchWmf( $clonePath ) {
		# Clone the repository
		$oldVersion = $this->oldVersion == 'master' ? 'master' : $this->branchPrefix . $this->oldVersion;
		$path = $clonePath ? $clonePath : "{$this->baseRepoPath}/core.git";
		$this->runCmd( 'git', 'clone', '-q', $path, '-b', $oldVersion, 'wmf' );

		$this->chdir( 'wmf' );

		# If we cloned from somewhere other than SSH, update remotes
		# and make sure our clone is up to date with origin
		if( $clonePath ) {
			$this->runCmd( 'git', 'remote', 'rm', 'origin' );
			$this->runCmd( 'git', 'remote', 'add', 'origin', "{$this->baseRepoPath}/core.git" );
			$this->runCmd( 'git', 'pull', '-q', '--ff-only', 'origin', $oldVersion );
		}

		# Look for the extensions we want to preserve the old branch's state
		$preservedRefs = array();
		foreach( $this->specialExtensions as $name => $copy ) {
			if( $copy === true ) {
				if( $this->oldVersion == 'master' ) {
					// There's nothing to copy in this instance, if you're trying
					// pin while oldVersion is master then use sha1's instead of true
					continue;
				} elseif( file_exists( "extension/$name" ) ) {
					$preservedRefs[$name] = file_get_contents( "extensions/$name" );
				} else {
					$this->croak( "Extension ($name) wants to copy from the old branch "
						. "but it doesn't exist there. Check configuration." );
				}
			} elseif( is_string( $copy ) ) {
				$preservedRefs[$name] = $copy;
			} else {
				$this->croak( "Extension ($name) misconfigured. Don't know how to proceed." );
			}
		}

		# Create a new branch from master and switch to it
		$newVersion = $this->branchPrefix . $this->newVersion;
		$this->runCmd( 'git', 'checkout', '-q', '-b', $newVersion );

		# Delete extensions/README and extensions/.gitignore if we branched master
		if( $this->oldVersion == 'master' ) {
			$this->runCmd( 'git', 'rm', '-q', "extensions/README", "extensions/.gitignore" );
		}

		# Add extension submodules
		foreach (
			array_merge( $this->normalExtensions, array_keys( $this->specialExtensions ), $this->branchedExtensions )
				as $name ) {
			if( in_array( $name, $this->branchedExtensions ) ) {
				$this->runCmd( 'git', 'submodule', 'add', '-b', $newVersion, '-q',
					"{$this->anonRepoPath}/extensions/{$name}.git", "extensions/$name" );
			} else {
				$this->runCmd( 'git', 'submodule', 'add', '-q',
					"{$this->anonRepoPath}/extensions/{$name}.git", "extensions/$name" );
			}
			if( isset( $preservedRefs[$name] ) ) {
				$this->chdir( "extensions/$name" );
				$this->runCmd( 'git', 'remote', 'update' );
				$this->runCmd( 'git', 'checkout', '-q', $preservedRefs[$name] );
				$this->chdir( "../.." );
			}
		}

		# Do intermediate commit
		$this->runCmd( 'git', 'commit', '-a', '-q', '-m', "Creating new WMF {$this->newVersion} branch" );

		# Apply patches
		foreach ( $this->patches as $patch => $subpath ) {
			// git fetch ssh://reedy@gerrit.wikimedia.org:29418/mediawiki/core refs/changes/06/7606/1 && git cherry-pick FETCH_HEAD
			$this->runCmd( 'git', 'fetch', $this->baseRepoPath . '/' . $subpath, $patch );
			$this->runCmd( 'git', 'cherry-pick', 'FETCH_HEAD' );
		}

		# Fix $wgVersion
		$this->fixVersion( "includes/DefaultSettings.php" );

		# Point gitreview defaultbranch at wmf/version
		$this->fixGitReview();

		# Do the final commit
		$this->runCmd( 'git', 'commit', '-a', '-q', '-m',
			"Applied patches to new WMF {$this->newVersion} branch" );

		$this->runWriteCmd( 'git', 'push', 'origin', 'wmf/' . $this->newVersion  );
	}

	function fixVersion( $fileName ) {
		$s = file_get_contents( $fileName );
		$s = preg_replace( '/^( \$wgVersion \s+ = \s+ )  [^;]*  ( ; \s* ) $/xm',
			"\\1'{$this->newVersion}'\\2", $s );
		file_put_contents( $fileName, $s );
	}

	function fixGitReview() {
		$s = file_get_contents( ".gitreview" );
		$s = str_replace( "defaultbranch=master", "defaultbranch=wmf/{$this->newVersion}", $s );
		file_put_contents( ".gitreview", $s );
	}
}
