#!/usr/bin/env php
<?php

class ExecException extends Exception {}

/**
 * get_args - validation on the command line arguments
 */
function get_args( $argv ) {
	if ( count( $argv ) == 3 ) {
		return array( $argv[1], $argv[2] );
	}
	else {
		print "usage: $argv[0] oldbranch newbranch\n";
		print "  example: $argv[0] gerrit/wmf/1.20wmf2 gerrit/wmf/1.20wmf3\n";
		exit(1);
	}
}

/**
 * capture_output - wrapper around exec to throw more useful exception when
 *  things go sideways
 */
function capture_output( $command ) {
	$cwd = getcwd();
	$output = array();
	exec( $command, $output, $status );
	if( $status != 0 ) {
		throw new ExecException( "Error in command: $command\nDirectory: $cwd\nStatus: $status\nOutput: ".print_r($output)."\n" );
	}
	return $output;
}

/**
 * get_extension_versions - get a list of records, one for each extension.  Each
 *   record contains "name", "oldrev", and "newrev"
 */
function get_extension_versions( $oldbranch, $newbranch ) {
	$retval = array();
	$extrecord = array();
	foreach ( explode( "\n", git_extension_diff_output( $oldbranch, $newbranch ) ) as $line ) {
		#diff --git a/extensions/AbuseFilter b/extensions/AbuseFilter
		if( preg_match( '!^diff --git a/extensions/([^\. ]+) b/extensions/([^\. ]+)!', $line, $matches ) ) {
			if ( $matches[1] === 'README' ) {
				continue;
			}

			if( count( $extrecord ) > 0 ) {
				$retval[] = $extrecord;
				$extrecord = array();
			}
			$extrecord['name'] = $matches[1];
		}
		#-Subproject commit 0c6faec654e25cd5ac8141d4c3f3793c2caeb0e9
		elseif( preg_match( '!^-Subproject commit ([a-f0-9]*)!', $line, $matches ) ){
			$extrecord['oldrev'] = $matches[1];
		}
		#+Subproject commit d693a1bca606473ae9ec8513ad90ddaa80de351d
		elseif( preg_match( '!^\+Subproject commit ([a-f0-9]*)!', $line, $matches ) ) {
			$extrecord['newrev'] = $matches[1];
			$retval[] = $extrecord;
			$extrecord = array();
		}
	}
	return $retval;
}

/**
 * Fetch an array of the change's subject for a given path, along with a bug number.
 */
function useful_git_log( $oldRev, $newRev, $ext = null ) {
	$gitDir = getcwd();
	$myDir = $ext ? "$gitDir/extensions/$ext" : $gitDir;
	if( !is_dir( $myDir ) ) {
		return "";
	}
	chdir( $myDir );
	$retval = full_git_log_as_array( $oldRev, $newRev );
	$gitLog = array();
	foreach( $retval as $commit ) {
		$lines = array_filter( explode( "\n", $commit['message'] ) );
		$first = true;
		$subject = '';
		$bugs = array();
		foreach( $lines as $line ) {
			if( $first ) {
				$first = false;
				if( preg_match( "/\(?(Bug|RT)\s*(\d+)\)?\s*(.+)/i", $line, $issueRes ) ) {
					$bugs[] = $issueRes[2];
					$subject = $issueRes[3];
				} else {
					$subject = $line;
				}
			} elseif( preg_match( "/(Bug|RT):\s*(\d+)/i", $line, $issueRes ) ) {
				$bugs[] = $issueRes[2];
			}
		}
		$baseLogEntry = "{{git|" . substr( $commit['hash'], 1, 8 ) . "}} - ";
		// Trim down to the first bit
		$subject = trim( ltrim( trim( $subject ), '-' ) );
		$subject = preg_replace( "/    .+$/i", '', $subject );
		$bugs = $bugs ? " (bug " . implode( ", bug ", $bugs ) . ")" : '';
		$gitLog[] = $baseLogEntry . $subject . $bugs;
	}
	chdir( $gitDir );
	return $gitLog;
}

function full_git_log_as_array( $oldRev, $newRev ) {
	$command = "git log --cherry-pick --right-only --no-merges $oldRev..$newRev";
	try {
		$output = capture_output( $command );
	} catch( ExecException $e ) {
		throw new Exception( "Problem with command: $command\n******** LIKELY CAUSE: you need to run 'git fetch --all' in an extension directory" );
	}
	$history = array();
	foreach( $output as $line ) {
		if( strpos( $line, 'commit ' ) === 0 ) {
			if( !empty( $commit ) ) {
				array_push( $history, $commit );
				unset( $commit );
			}
			$commit['hash']   = substr( $line, strlen( 'commit' ) );
			continue;
		} elseif( strpos( $line, 'Author' ) === 0 || strpos( $line, 'Date' ) === 0 ) {
			continue;
		} else {
			if( isset( $commit['message'] ) ) {
				$commit['message'] .= "\n" . $line;
			} else {
				$commit['message'] = $line;
			}
			continue;
		}
		if( !empty( $commit ) ) {
		    array_push($history, $commit);
		}
	}
	return $history;
}

/**
 * git_extension_diff_output - git command for getting the diff list for extensions.
 */
function git_extension_diff_output( $oldbranch, $newbranch ) {
	return shell_exec( "git diff $oldbranch $newbranch extensions" );
}

/**
 * filter_git_output - perform any extra functions needed prior to posting to
 *  a wiki page (sanitization, making obvious removals, linking bugs, etc)
 */
function filter_git_output( $logoutput ) {
	$retval = '';
	if ( !$logoutput ) {
		return $retval;
	}
	$skipLines = array(
		'Localisation updates from',
		'COMMITMSG', // Fix for escaping fail leaving a commit summary of $COMMITMSG
		'Add (\.gitreview and )?\.gitignore',
		'Creating new WMF',
		'Commit of various live hacks', // Our catchall patch for live hacky stuff
		'Applied patches to new WMF',
		'(Updat(e|ing) )? ?.*? to (master|head|[0-9a-f]{5,40}|production tip)', // Update foo to master
		'Bump .*? for deployment',
	);
	foreach ( $logoutput as $line ) {
		foreach( $skipLines as $skip ) {
			if ( preg_match( '/' . $skip . '/i', $line ) ) {
				continue 2;
			}
		}
		$line = preg_replace( '/bug:?\s*(\d+)/i', '{{bugzilla|$1}}', $line );
		$line = htmlspecialchars( $line );
		$retval .= "* $line\n";
	}
	return $retval;
}

/**
 *
 */
function get_all_extension_change_markup( $oldbranch, $newbranch ) {
	$retval = '';
	$extrecords = get_extension_versions( $oldbranch, $newbranch );
	foreach ( $extrecords as $extrecord ) {
		if( !array_key_exists( 'oldrev', $extrecord ) ) {
			$logoutput = array( "** Newly deployed extension" );
		}
		elseif( !array_key_exists( 'newrev', $extrecord ) ) {
			$logoutput = useful_git_log( $extrecord['oldrev'], "HEAD", $extrecord['name'] );
		}
		else {
			$logoutput = useful_git_log( $extrecord['oldrev'], $extrecord['newrev'], $extrecord['name'] );
		}
		$changes = filter_git_output( $logoutput );
		if( $changes != "" ) {
			$retval .= '=== ' . $extrecord['name'] . " ===\n";
			$retval .= $changes;
		}
	}
	return $retval;
}

/**
 * Main program flow
 * Get changes for core (git_cherry_log_output_core + filter_git_output)
 * Get extension markup (get_all_extension_change_markup)
 *   -> Get list of extensions (get_extension_versions)
 *   -> On each extension:
 *      ->  Get changes and filter (get_cherry_log_output_extension + filter_git_output)
 */
function main( $argv ) {
	list( $oldbranch, $newbranch ) = get_args( $argv );
	print "== Core changes ==\n";
	$coreoutput = useful_git_log( $oldbranch, $newbranch );
	print filter_git_output( $coreoutput );
	print "== Extensions ==\n";
	print get_all_extension_change_markup( $oldbranch, $newbranch );
}

main( $argv );

