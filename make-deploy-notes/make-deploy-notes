#!/usr/bin/env php
<?php

/**
 * Class ExecException
 */
class ExecException extends Exception {}

/**
 * Validation on the command line arguments
 * @param array $argv
 * @return array
 */
function get_args( $argv ) {
	if ( count( $argv ) == 3 ) {
		return array( $argv[1], $argv[2] );
	} else {
		print "usage: $argv[0] oldbranch newbranch\n";
		print "  example: $argv[0] gerrit/wmf/1.20wmf2 gerrit/wmf/1.20wmf3\n";
		exit(1);
	}
}

/**
 * Wrapper around exec to throw more useful exception when
 * things go sideways
 * @param string $command
 * @throws ExecException
 * @return array
 */
function capture_output( $command ) {
	$cwd = getcwd();
	$output = array();
	exec( $command, $output, $status );
	if( $status != 0 ) {
		throw new ExecException( "Error in command: $command\nDirectory: $cwd\nStatus: $status\nOutput: "
			. print_r( $output) . "\n"
		);
	}
	return $output;
}

/**
 * Get a list of records, one for each extension.
 *  Each record contains "name", "oldrev", and "newrev"
 * @param string $oldbranch
 * @param string $newbranch
 * @return array
 */
function get_extension_versions( $oldbranch, $newbranch ) {
	$retval = array();
	$extrecord = array();
	foreach ( explode( "\n", git_extension_diff_output( $oldbranch, $newbranch ) ) as $line ) {
		#diff --git a/extensions/AbuseFilter b/extensions/AbuseFilter
		if( preg_match( '!^diff --git a/extensions/([^\. ]+) b/extensions/([^\. ]+)!', $line, $matches ) ) {
			if ( $matches[1] === 'README' ) {
				continue;
			}

			if( count( $extrecord ) > 0 ) {
				$retval[] = $extrecord;
				$extrecord = array();
			}
			$extrecord['name'] = $matches[1];
		}
		#-Subproject commit 0c6faec654e25cd5ac8141d4c3f3793c2caeb0e9
		elseif( preg_match( '!^-Subproject commit ([a-f0-9]*)!', $line, $matches ) ){
			$extrecord['oldrev'] = $matches[1];
		}
		#+Subproject commit d693a1bca606473ae9ec8513ad90ddaa80de351d
		elseif( preg_match( '!^\+Subproject commit ([a-f0-9]*)!', $line, $matches ) ) {
			$extrecord['newrev'] = $matches[1];
			$retval[] = $extrecord;
			$extrecord = array();
		}
	}
	return $retval;
}

/**
 * Fetch an array of the change's subject for a given path, along with a bug number.
 * @param string $oldRev
 * @param string $newRev
 * @param null|string $ext
 * @throws Exception
 * @return array
 */
function useful_git_log( $oldRev, $newRev, $ext = null ) {
	$gitDir = getcwd();
	$myDir = $ext ? "$gitDir/extensions/$ext" : $gitDir;
	if( !is_dir( $myDir ) ) {
		return "";
	}
	chdir( $myDir );
	$retval = full_git_log_as_array( $oldRev, $newRev );
	$gitLog = array();
	foreach( $retval as $commit ) {
		$lines = array_filter( explode( "\n", $commit['message'] ) );
		$first = true;
		$subject = '';
		$bugs = array();
		foreach( $lines as $line ) {
			if( $first ) {
				$first = false;
				if( preg_match( "/\(?(Bug|RT)\s*(\d+)\)?\s*(.+)/i", $line, $issueRes ) ) {
					$bugs[] = $issueRes[2];
					$subject = $issueRes[3];
				} else {
					$subject = $line;
				}
			} elseif( preg_match( "/(Bug|RT):\s*(\d+)/i", $line, $issueRes ) ) {
				$bugs[] = $issueRes[2];
			}
		}
		// Trim down to the first bit
		$subject = trim( ltrim( trim( $subject ), '-' ) );
		$subject = preg_replace( "/    .+$/i", '', $subject );
		$gitLog[] = array(
			'hash' => substr( $commit['hash'], 1, 8 ),
			'subject' => $subject,
			'bugs' => $bugs,
		);
	}
	chdir( $gitDir );
	return $gitLog;
}

/**
 * @param string $oldRev
 * @param string $newRev
 * @return array
 * @throws Exception
 */
function full_git_log_as_array( $oldRev, $newRev ) {
	$command = "git log --format=medium --cherry-pick --right-only --no-merges $oldRev..$newRev";
	try {
		$output = capture_output( $command );
	} catch( ExecException $e ) {
		throw new Exception( "Problem with command: $command\n******** LIKELY CAUSE: you need to run 'git fetch --all' in an extension directory" );
	}
	$history = array();
	foreach( $output as $line ) {
		if( strpos( $line, 'commit ' ) === 0 ) {
			if( !empty( $commit ) ) {
				array_push( $history, $commit );
				unset( $commit );
			}
			$commit['hash']   = substr( $line, strlen( 'commit' ) );
			continue;
		} elseif( strpos( $line, 'Author' ) === 0 || strpos( $line, 'Date' ) === 0 ) {
			continue;
		} else {
			if( isset( $commit['message'] ) ) {
				$commit['message'] .= "\n" . $line;
			} else {
				$commit['message'] = $line;
			}
			continue;
		}
	}
	return $history;
}

/**
 * git command for getting the diff list for extensions.
 * @param string $oldbranch
 * @param string $newbranch
 * @return string
 */
function git_extension_diff_output( $oldbranch, $newbranch ) {
	return shell_exec( "git diff $oldbranch $newbranch extensions" );
}

/**
 * filter_git_output - perform any extra functions needed prior to posting to
 *  a wiki page (sanitization, making obvious removals, linking bugs, etc)
 * @param array $logoutput
 * @return string
 */
function filter_git_output( $logoutput ) {
	$retval = '';
	if ( !$logoutput ) {
		return $retval;
	}

	$skipLines = array(
		'Localisation updates from',
		'COMMITMSG', // Fix for escaping fail leaving a commit summary of $COMMITMSG
		'Add (\.gitreview and )?\.gitignore',
		'Creating new WMF',
		'Commit of various live hacks', // Our catchall patch for live hacky stuff
		'Applied patches to new WMF',
		'(Updat(e|ing) )? ?.*? to (master|head|[0-9a-f]{5,40}|production tip)', // Update foo to master
		'Bump .*? for deployment',
	);
	foreach ( $logoutput as $record ) {
		foreach( $skipLines as $skip ) {
			if ( preg_match( '/' . $skip . '/i', $record['subject'] ) ) {
				continue 2;
			}
		}

		$retval .= "* {{git|{$record['hash']}}} - <nowiki>";
		$retval .= htmlspecialchars( $record['subject'] ) . '</nowiki>';
		if ( $record['bugs'] ) {
			$retval .= ' (';
			$retval .= implode( ", ", array_map( function( $b ) {
				return "{{bugzilla|{$b}}}";
			}, $record['bugs'] ) );
			$retval .= ')';
		}
		$retval .= "\n";
	}
	return $retval;
}

/**
 * @param string $oldbranch
 * @param string $newbranch
 * @return string
 */
function get_all_extension_change_markup( $oldbranch, $newbranch ) {
	$retval = '';
	$extrecords = get_extension_versions( $oldbranch, $newbranch );
	foreach ( $extrecords as $extrecord ) {
		if( !array_key_exists( 'oldrev', $extrecord ) ) {
			$retval .= get_change_log( $extrecord['name'], "** Newly deployed extension\n" );
			continue;
		} elseif( !array_key_exists( 'newrev', $extrecord ) ) {
			$logoutput = useful_git_log( $extrecord['oldrev'], 'HEAD', $extrecord['name'] );
		} else {
			$logoutput = useful_git_log( $extrecord['oldrev'], $extrecord['newrev'], $extrecord['name'] );
		}
		$changes = filter_git_output( $logoutput );
		if( $changes != "" ) {
			$retval .= get_change_log( $extrecord['name'], $changes );
		}
	}
	return $retval;
}

/**
 * Gets a final change log entry
 *
 * @param string $name
 * @param string $changes
 * @return string
 */
function get_change_log( $name, $changes ) {
	return '=== ' . $name . " ===\n" . $changes;
}

/**
 * Main program flow
 * Get changes for core (git_cherry_log_output_core + filter_git_output)
 * Get extension markup (get_all_extension_change_markup)
 *   -> Get list of extensions (get_extension_versions)
 *   -> On each extension:
 *      ->  Get changes and filter (get_cherry_log_output_extension + filter_git_output)
 * @param array $argv
 */
function main( $argv ) {
	list( $oldbranch, $newbranch ) = get_args( $argv );
	print "== Core changes ==\n";
	$coreoutput = useful_git_log( $oldbranch, $newbranch );
	print filter_git_output( $coreoutput );
	print "== Extensions ==\n";
	print get_all_extension_change_markup( $oldbranch, $newbranch );
}

main( $argv );

