#!/usr/bin/env php
<?php
/**
 * Create branches in all Wikimedia-hosted extension/skin repositories.
 * Run this script after mediawiki/core has branched. Then figure
 * out the timestamp of when it was branched as follows:
 *
 * Example for REL1_21:
 *
 * $ cd mediawiki/core
 * $ git log --right-only --oneline gerrit/master...gerrit/REL1_21
 *
 * Get the last one and take note of the the commit hash.
 * This commit is the first one that is in REl1_21 but not in master.
 * Now get the CommitDate (not AuthorDate) of the parent of that commit, which
 * is the last commit that is both in master and in the release branch.
 * We can instruct git to access the parent by tacking "~1" to the hash:
 *
 * $ git show --format=fuller --quiet 4cb0dc1~1
 *   commit 49eacb3b3ae9cebdc7a407360454af3c1e33b3c9
 *   CommitDate: Sat Mar 16 12:00:59 2013 +0000
 *
 * @author Chad Horohoe, 2012
 * @author Timo Tijhof, 2013
 * @license WTFPL (See LICENSE file)
 */

if ( php_sapi_name() !== 'cli' ) {
	echo "This script only works from the command line\n";
	exit( 1 );
}

$self = basename( __FILE__ );

if ( count( $argv ) < 3 ) {
	echo
		"usage: $self <branch-name> '<branch-date>'\n"
		. "\n"
		. "Example: $self REL1_21 'Sat Mar 16 12:00:59 2013 +0000'\n";
	exit( 1 );
}

$maker = new MakeExtensionBranches( array(
	'branchName' => $argv[1],
	'branchDate' => $argv[2],
) );

$maker->start();

class MakeExtensionBranches {

	protected $codeDir, $buildDir;
	protected $conf, $opts;

	public function __construct( $opts ) {
		$this->codeDir = __DIR__;
		$this->buildDir = sys_get_temp_dir() . '/make-extension-branches';

		require "{$this->codeDir}/default.conf";
		if ( file_exists( "{$this->codeDir}/local.conf" ) ) {
			require "{$this->codeDir}/local.conf";
		}

		$this->conf = $conf;
		$this->opts = (object) $opts;

	}

	protected function setup() {
		if ( !$this->conf->extRepos ) {
			// Fetch from Gerit
			$cmd = 'ssh -p 29418 gerrit.wikimedia.org gerrit ls-projects -p';
			$list = array_merge(
				explode( "\n", shell_exec( "$cmd mediawiki/extensions" ) ),
				explode( "\n", shell_exec( "$cmd mediawiki/skins" ) )
			);
			// Trim leading/trailing whitespace
			$list = array_map( 'trim', $list );
			// Ignore empty lines
			$list = array_filter( $list );

			$this->conf->extRepos = $list;
		}
	}

	public function start() {
		$this->setup();
		$this->setupBuildDirectory();
		array_walk( $this->conf->extRepos, array( $this, 'doExt' ), $this->opts->branchName );
		echo "Done!\n";
	}


	public function doExt( $extRepo, $unusedKey, $branchName ) {
		// Move back to the build dir in each loop,
		// otherwise we'll get build/AntiBot/CategoryTree/.. instead of build/AntiBot, build/CategoryTree, ..
		$this->chdir( $this->buildDir );
		echo "... $extRepo\n";
		$url = str_replace( '{repository}', $extRepo, $this->conf->extRepoUrlFormat );
		$name = basename( $extRepo );
		$this->execCmd( 'git', 'clone', '-q', $url, '-b', 'master', $name );
		$this->chdir( $name );

		$out = $exitcode = null;
		// Check if the branch exists already
		exec( 'git show-branch origin/' . escapeshellarg( $branchName ) . ' 2>&1', $out, $exitcode );
		if ( $exitcode == 0 ) {
			echo "Skipping $extRepo: Branch exists already\n";
			return;
		}
		$commit = $this->execReadCmd( 'git', 'rev-list', '-n', '1', '--before', $this->opts->branchDate, 'master' );
		if ( !$commit ) {
			echo "Skipping $extRepo: Repo does not have a commit before the branch date\n";
			return;
		}
		if ( $this->conf->verbose ) {
			echo "... $extRepo: Branching $branchName at $commit\n";
		}
		$this->execCmd( 'git', 'checkout', '-q', '-b', $branchName, $commit );

		# Intermediate commit & fixes
		$this->fixGitReview( $branchName );
		$this->execCmd( 'git', 'commit', '-a', '-q', '-m', "Creating new {$branchName} branch" );

		# Final push to repo for this extension/skin
		$this->execWriteCmd( 'git', 'push', 'origin', "$branchName:refs/heads/$branchName" );
	}

	protected function setupBuildDirectory() {
		if ( is_dir( $this->buildDir ) ) {
			$this->execCmd( 'rm', '-rf', '--', $this->buildDir );
		}
		if ( !mkdir( $this->buildDir ) ) {
			$this->error( "Unable to create directory {$this->buildDir}" );
		}
	}

	protected function chdir( $dir ) {
		if ( !chdir( $dir ) ) {
			$this->error( "Unable to change working directory to $dir\n" );
		}
		if ( $this->conf->verbose ) {
			echo "[cwd] $dir\n";
		}
	}

	protected function execCmd( /*...*/ ) {
		$args = func_get_args();
		if ( $this->conf->verbose && in_array( '-q', $args ) ) {
			$args = array_diff( $args, array( '-q' ) );
		}
		$cmd = implode( ' ', array_map( 'escapeshellarg', $args ) );
		if ( $this->conf->verbose ) {
			echo "[exec] $cmd\n";
		}
		$ret = null;
		passthru( $cmd, $ret );
		if ( $ret ) {
			$this->error( $args[0] . " exit with status $ret\n" );
		}
	}

	protected function execReadCmd( /*...*/ ) {
		$cmd = implode( ' ', array_map( 'escapeshellarg', func_get_args() ) );
		if ( $this->conf->verbose ) {
			echo "[exec] $cmd\n";
		}
		$ret = null;
		ob_start();
		passthru( $cmd, $ret );
		$output = ob_get_contents();
		ob_end_clean();
		if ( $ret ) {
			$this->error( $args[0] . " exit with status $ret\n" );
		}
		return trim( $output );
	}

	protected function fixGitReview( $branchName ) {
		$s = file_get_contents( ".gitreview" );
		$s = str_replace( "defaultbranch=master", "defaultbranch={$branchName}", $s );
		file_put_contents( ".gitreview", $s );
	}

	/**
	 * Commands that are guarded behind conf->dryRun.
	 */
	protected function execWriteCmd( /*...*/ ) {
		$args = func_get_args();
		$cmd = implode( ' ', array_map( 'escapeshellarg', $args ) );
		if ( $this->conf->dryRun ) {
			echo "[dryRun] $cmd\n";
		} else {
			call_user_func_array( array( $this, 'execCmd' ), $args );
		}
	}

	protected function error( $msg ) {
		fwrite( STDERR, "$msg\n" );
		exit( 1 );
	}
}
