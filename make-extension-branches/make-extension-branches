#!/usr/bin/env php
<?php
/**
 * Create branches in all Wikimedia-hosted extension repositories.
 * Run this script after mediawiki/core has branched. Then figure
 * out the timestamp of when it was branched as follows:
 *
 * Example for REL1_21:
 *
 * $ cd mediawiki/core
 * $ git log --right-only --oneline gerrit/master...gerrit/REL1_21
 *
 * Get the last one and take note of the the commit hash.
 * This commit is the first one that is in REl1_21 but not in master.
 * Now get the CommitDate (not AuthorDate) of the parent of that commit, which
 * is the last commit that is both in master and in the release branch.
 * We can instruct git to access the parent by tacking "~1" to the hash:
 *
 * $ git show --format=fuller --quiet 4cb0dc1~1
 *   commit 49eacb3b3ae9cebdc7a407360454af3c1e33b3c9
 *   CommitDate: Sat Mar 16 12:00:59 2013 +0000
 *
 * @author Chad Horohoe, 2012
 * @author Timo Tijhof, 2013
 * @license WTFPL (See LICENSE file)
 */

if ( php_sapi_name() !== 'cli' ) {
	echo "This script only works from the command line\n";
	exit( 1 );
}

$self = basename( __FILE__ );

if ( count( $argv ) < 3 ) {
	echo
		"usage: $self <branch-name> '<branch-date>'\n"
		. "\n"
		. "Example: $self REL1_21 'Sat Mar 16 12:00:59 2013 +0000'\n";
	exit( 1 );
}

$maker = new MakeExtensionBranches( array(
	'branchName' => $argv[1],
	'branchDate' => $argv[2],
) );

$maker->start();

class MakeExtensionBranches {

	protected $codeDir;
	protected $conf, $opts;

	public function __construct( $opts ) {
		$this->codeDir = __DIR__;

		require "{$this->codeDir}/default.conf";
		if ( file_exists( "{$this->codeDir}/local.conf" ) ) {
			require "{$this->codeDir}/local.conf";
		}

		$this->conf = $conf;
		$this->opts = (object) $opts;

	}

	protected function setup() {
		if ( !$this->conf->extRepos ) {
			// Fetch from Gerit
			$list = explode( "\n", shell_exec( 'ssh -p 29418 gerrit.wikimedia.org gerrit ls-projects -p mediawiki/extensions' ) );
			// Trim leading/trailing whitespace
			$list = array_map( 'trim', $list );
			// Ignore empty lines
			$list = array_filter( $list );

			$this->conf->extRepos = $list;
		}
	}

	public function start() {
		$this->setup();
		if ( !$this->conf->reuseDir ) {
			$this->setupBuildDirectory( $this->conf->buildDir );
		}

		$branchName = $this->opts->branchName;
		foreach ( $this->conf->extRepos as $extRepo ) {
			// Move back to the build dir in each loop,
			// otherwise we'll get build/AntiBot/CategoryTree/.. instead of build/AntiBot, build/CategoryTree, ..
			$this->chdir( $this->conf->buildDir );

			if ( $extRepo === 'mediawiki/extensions' ) {
				// Skip the meta repository
				continue;
			}
			$name = substr( $extRepo, strlen( "mediawiki/extensions/" ) );
			echo "... $extRepo\n";
			$url = str_replace( '{repository}', $extRepo, $this->conf->extRepoUrlFormat );
			if ( file_exists( $name ) ) {
				if ( !$this->conf->reuseDir ) {
					echo "$name already exists.  Can't continue.";
					exit(1);
				} elseif ( !is_dir( "$name/.git" ) ) {
					echo "$name is not a git repo.  Can't continue.";
					exit(1);
				}
			}

			if ( !$this->conf->reuseDir || !file_exists( $name ) ) {
				$this->execCmd( 'git', 'clone', '-q', $url, $name );
			}

			$this->chdir( $name );

			$out = $exitcode = null;
			// Check if the branch exists already
			exec( 'git show-branch origin/' . escapeshellarg( $branchName ) . ' 2>&1', $out, $exitcode );
			if ( $exitcode == 0 ) {
				echo "Skipping $extRepo: Branch exists already\n";
				continue;
			}
			$commit = false;
			if( array_filter( $this->getBranches(), function($b) { return $b === "master" || $b === "* master"; } ) ) {
				list( $exitcode, $commit ) = $this->execReadCmd( 'git', 'rev-list', '-n', '1', '--before',
					$this->opts->branchDate, 'master' );
			}
			if ( !$commit ) {
				echo "Skipping $extRepo: Repo does not have a commit before the branch date\n";
				continue;
			}
			if ( $this->conf->verbose ) {
				echo "... $extRepo: Branching $branchName at $commit\n";
			}
			$match = array_filter( $this->getBranches(), function($l) use ($branchName) { return trim( $l ) === $branchName; } );
			if ( count( $match ) ) {
				$this->execWriteCmd( 'git', 'branch', '-D', $branchName );
			}
			$this->execCmd( 'git', 'checkout', '-q', $commit );
			$exitcode = $this->execWriteCmd( 'git', 'branch', $branchName );
			if ( $exitcode != 0 ) {
				if ( $exitcode != 128 || !$this->conf->reuseDir ) {
					echo "Skipping $extRepo: Creating branch failed (exit code: $exitcode)\n";
					continue;
				}
			}

			# Intermediate commit & fixes
			if( $this->fixGitReview( $branchName, $name ) ) {
				$this->execWriteCmd( 'git', 'commit', '-a', '-q', '-m', "Creating new {$branchName} branch" );
			} else {
				echo "Trouble with $name\n";
				exit;
			}

			# Final push to repo for this extension
			$this->execWriteCmd( 'git', 'push', 'origin', "$branchName:refs/heads/$branchName" );
		}

		echo "Done!\n";
	}

	protected function setupBuildDirectory( $buildDir ) {
		if ( is_dir( $buildDir ) ) {
			$this->execCmd( 'rm', '-rf', '--', $buildDir );
		}
		if ( !mkdir( $buildDir ) ) {
			$this->error( "Unable to create directory {$buildDir}" );
		}
	}

	protected function chdir( $dir ) {
		if ( !chdir( $dir ) ) {
			$this->error( "Unable to change working directory to $dir\n" );
		}
		if ( $this->conf->verbose ) {
			echo "[cwd] $dir\n";
		}
	}

	protected function execCmd( /*...*/ ) {
		$args = func_get_args();
		if ( $this->conf->verbose && in_array( '-q', $args ) ) {
			$args = array_diff( $args, array( '-q' ) );
		}
		$cmd = implode( ' ', array_map( 'escapeshellarg', $args ) );
		if ( $this->conf->verbose ) {
			echo "[exec] $cmd\n";
			if( ob_get_contents() ) {
				ob_clean();
			}
		}
		$ret = null;
		passthru( $cmd, $ret );
		if ( $ret ) {
			$cont = ob_get_contents();
			$this->error( $args[0] . " exit with status $ret\n" );
			if( $cont ) {
				ob_clean();
				echo $cont;
			}
			exit(1);
		}
		return $ret;
	}

	protected function execReadCmd( /*...*/ ) {
		$args = func_get_args();
		ob_start();
		$ret = call_user_func_array( array( $this, 'execCmd' ), $args );
		$output = ob_get_contents();
		ob_end_clean();
		return array( $ret, trim( $output ) );
	}

	protected function fixGitReview( $branchName, $project ) {
		if ( !file_exists( ".gitreview" ) ) {
			$review = array();
			$review[] = "[gerrit]";
			$review[] = "host=gerrit.wikimedia.org";
			$review[] = "port=29418";
			$review[] = "project=mediawiki/extensions/$project.git";
			$review[] = "defaultbranch=$branchName";
			$review[] = "defaultrebase=0";

			echo "No .gitreview! Creating...\n";
			$ret = file_put_contents( ".gitreview", implode( "\n", $review ) );
			if ( $ret === false ) {
				$err = error_get_last();
				$this->error( "Error writing .gitreview: {$err['message']}\n" );
				return false;
			}

			$this->execCmd( "git", "add", ".gitreview" );
			return true;
		}
		echo "Fixing .gitreview\n";

		$s = file_get_contents( ".gitreview" );
		$s = str_replace( "defaultbranch=master", "defaultbranch={$branchName}", $s );
		$ret = file_put_contents( ".gitreview", $s );
		if ( $ret === false ) {
			$err = error_get_last();
			$this->error( "Error writing .gitreview: {$err['message']}\n" );
			return false;
		}
		$this->execCmd( "git", "add", '-f', ".gitreview" );
		return true;
	}

	/**
	 * Commands that are guarded behind conf->dryRun.
	 */
	protected function execWriteCmd( /*...*/ ) {
		$args = func_get_args();
		$cmd = implode( ' ', array_map( 'escapeshellarg', $args ) );
		if ( $this->conf->dryRun ) {
			echo "[dryRun] $cmd\n";
		} else {
			call_user_func_array( array( $this, 'execCmd' ), $args );
		}
	}

	protected function error( $msg ) {
		fwrite( STDERR, "$msg\n" );
	}

	protected function getBranches( ) {
		list( $exitcode, $output ) = $this->execReadCmd( 'git', 'branch', '-a' );
		return array_map( "trim", explode( "\n", $output ) );
	}
}
